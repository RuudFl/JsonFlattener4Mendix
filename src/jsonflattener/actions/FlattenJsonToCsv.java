// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package jsonflattener.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import java.io.StringWriter;
import java.io.PrintWriter;

public class FlattenJsonToCsv extends CustomJavaAction<java.lang.String>
{
	private java.lang.String jsonString;

	public FlattenJsonToCsv(IContext context, java.lang.String jsonString)
	{
		super(context);
		this.jsonString = jsonString;
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		// BEGIN USER CODE
        // Parse the JSON string
        JsonElement rootElement = JsonParser.parseString(jsonString);
        
        // Convert to array if it's a single object
        JsonArray jsonArray;
        if (rootElement.isJsonObject()) {
            // Single object - wrap in array
            jsonArray = new JsonArray();
            jsonArray.add(rootElement.getAsJsonObject());
        } else if (rootElement.isJsonArray()) {
            // Already an array
            jsonArray = rootElement.getAsJsonArray();
        } else {
            throw new IllegalArgumentException("JSON must be either an object or an array");
        }
        
        // Collect all unique column names across all records (maintaining order)
        LinkedHashMap<String, Integer> allColumns = new LinkedHashMap<>();
        List<Map<String, String>> flatRecords = new ArrayList<>();
        
        // Flatten each record
        for (JsonElement element : jsonArray) {
            if (!element.isJsonObject()) {
                continue; // Skip non-object elements in array
            }
            
            Map<String, String> flatRecord = new LinkedHashMap<>();
            flattenJson("", element.getAsJsonObject(), flatRecord);
            flatRecords.add(flatRecord);
            
            // Track all columns
            for (String key : flatRecord.keySet()) {
                allColumns.put(key, 1);
            }
        }
        
        // Build CSV
        StringWriter stringWriter = new StringWriter();
        PrintWriter writer = new PrintWriter(stringWriter);
        
        // Write header
        List<String> columnList = new ArrayList<>(allColumns.keySet());
        writer.println(String.join(",", columnList.stream()
            .map(this::escapeCsvValue)
            .toArray(String[]::new)));
        
        // Write data rows
        for (Map<String, String> record : flatRecords) {
            List<String> row = new ArrayList<>();
            for (String column : columnList) {
                String value = record.getOrDefault(column, "");
                row.add(escapeCsvValue(value));
            }
            writer.println(String.join(",", row));
        }
        
        writer.flush();
        return stringWriter.toString();
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "FlattenJsonToCsv";
	}

	// BEGIN EXTRA CODE
    private void flattenJson(String prefix, JsonObject jsonObject, Map<String, String> result) {
        // Use entrySet to maintain order
        for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {
            String key = prefix.isEmpty() ? entry.getKey() : prefix + "." + entry.getKey();
            JsonElement value = entry.getValue();
            
            if (value.isJsonNull()) {
                result.put(key, "");
            } else if (value.isJsonPrimitive()) {
                result.put(key, value.getAsString());
            } else if (value.isJsonObject()) {
                flattenJson(key, value.getAsJsonObject(), result);
            } else if (value.isJsonArray()) {
                flattenJsonArray(key, value.getAsJsonArray(), result);
            }
        }
    }
    
    private void flattenJsonArray(String prefix, JsonArray jsonArray, Map<String, String> result) {
        if (jsonArray.size() == 0) {
            result.put(prefix, "");
            return;
        }
        
        for (int i = 0; i < jsonArray.size(); i++) {
            JsonElement element = jsonArray.get(i);
            String arrayKey = prefix + "." + i;
            
            if (element.isJsonNull()) {
                result.put(arrayKey, "");
            } else if (element.isJsonPrimitive()) {
                result.put(arrayKey, element.getAsString());
            } else if (element.isJsonObject()) {
                flattenJson(arrayKey, element.getAsJsonObject(), result);
            } else if (element.isJsonArray()) {
                flattenJsonArray(arrayKey, element.getAsJsonArray(), result);
            }
        }
    }
    
    private String escapeCsvValue(String value) {
        if (value == null) {
            return "";
        }
        
        // Escape quotes and wrap in quotes if contains comma, quote, or newline
        if (value.contains("\"") || value.contains(",") || value.contains("\n") || value.contains("\r")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        
        return value;
    }
	// END EXTRA CODE
}
